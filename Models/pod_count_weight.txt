model{ #Model of seed count per pod ~ pod weight relationship
#Lognorm - bad p.pred. checks
#Gamma - bad p. pred. checks

#Priors #####

# Novules <- 120 #Ovule number, set as fixed. Not enough info to estimate relationships otherwise...
# int.Pol ~ dnorm(-3,.1)  #Probability of ovule fertilization
# slope.Fert ~ dnorm(0.1,.1) #Probability of seed development 

# int.PodMass ~ dnorm(0,0.01) #Intercept of weight-count relationship
# slope.PodMass ~ dnorm(0,0.01) #Intercept of weight-count relationship
# prec.PodMass ~ dgamma(0.01,0.01) #Precision of pod weight

#Pollination rate
lambda ~ dnorm(5.6,0.1) 
r ~ dgamma(2,3)
# lambda <- 5.685
# r <- 0.615
#Pollen success probability
intPol ~ dnorm(0,10) #intercept
slopePol1 ~ dgamma(1,1) #slope1
slopePol2 ~ dnorm(-3.1,1) #slope2
polBp ~ dgamma(3,8) #breakpoint location

p <- r/(r+exp(lambda)) #Transformed mean for pollination process (about 0.0022)
		 
	for(pol in 1:Npollen){
		PollenCount[pol] ~ dnegbin(p,r)	#Actual pollen counts	
	}
	
	for(pod in 1:Npod){		
		simPollenCount[pod] ~ dnegbin(p,r) T(1,1500) #Simulate pollen counts on stigmas (truncate between 1 and 1500)		
		#simPollenCountZero[pod] ~ dnegbin(p,r) T(0,1) #Only zeros - doesn't generate zeros properly...
		simOvCount[pod] ~ dpois(32) T(1,52) #Simulate ovule counts per pod (truncate between 1,52)
		#logit(probPol[pod]) <- intPol - slopePol1*simPollenCount[pod]/10000 #Probability of pollen success	
		log(probPol[pod]) <- ifelse(simPollenCount[pod]<polBp, #Breakpoint function for pollen receipt. 
			intPol-slopePol1*(simPollenCount[pod]/1000),
			polBp*(-slopePol1)+((simPollenCount[pod]/1000)-polBp)*slopePol2+intPol)
		simFertSeed[pod]~ dpois(probPol[pod]*simPollenCount[pod]) T(1,simOvCount[pod])  #Fertilized seeds 		
		 
		# SeedCount[pod] ~ dpois(simFertSeed[pod]) 
		# resSeedCount[pod] <- abs(SeedCount[pod]-probPol[pod]*simOvCount[pod]) #Diff b/w predicted and actual
		# simSeedCount[pod] ~ dpois(probPol[pod]*simOvCount[pod])  #Simulate Fertilized seeds
		# resSimSeedCount[pod] <- abs(simSeedCount[pod]-SeedCount[pod]) #Diff b/w simulated and actual
	}

	# for(pod in 1:Npod){
		
		# Number of ovules that become fertilized (conditioned on Novules)
		# log(p1[pod]) <- int.Pol 
		# FertCount[pod] ~ dpois(p1[pod]*Novules) 
		
		# Number of fertilized ovules that become seeds (conditioned on FertCount)
		# log(p2[pod]) <- slope.Fert*FertCount[pod] #Model has trouble converging with an intercept term, and has bad p.pred. checks.		
		# SeedCount[pod] ~ dpois((p2[pod]*FertCount[pod])+0.01) 
		
		# #Podweight ~ SeedCount
		# mu.PodMass[pod] <- int.PodMass+slope.PodMass*SeedCount[pod]
		# PodMass[pod] ~ dlnorm(mu.PodMass[pod],prec.PodMass)

		# Posterior predictive checks:
		
		# #Seed count
		# res.SeedCount[pod] <- abs(SeedCount[pod] - p2[pod]*FertCount[pod])
		# #Generate new dataset
		# SeedCount.new[pod] ~ dpois(p2[pod]*FertCount[pod])
		# res.SeedCount.new[pod] <- abs(SeedCount.new[pod] - p2[pod]*FertCount[pod])		
		
		# #Pod weight
		# res.PodMass[pod] <- abs(PodMass[pod] - exp(mu.PodMass[pod]+(1/2*prec.PodMass))) #exp(mu) = median, mean = exp(mu+(sigma^2)/2) = exp(mu + 1/2tau)
		# #Generate new dataset
		# PodMass.new[pod] ~ dlnorm(mu.PodMass[pod],prec.PodMass)
		# res.PodMass.new[pod] <- abs(PodMass.new[pod] - exp(mu.PodMass[pod]+(1/2*prec.PodMass)))	
	# }
	
#Posterior predictive checks
# fitSeedCount <- sum(resSeedCount[]) #Seed count resids
# fitSimSeedCount <- sum(resSimSeedCount[]) #Simulated seed count resids

# fit.PodMass <- sum(res.PodMass[]) #Pod mass
# fit.PodMass.new <- sum(res.PodMass.new[])	
}